<?xml version = '1.0' encoding = 'UTF-8'?>
<PackageOracle class="oracle.dbtools.crest.model.design.storage.oracle.PackageOracle" name="WT_ASSERT" directorySegmentName="seg_0" id="D41A0DE0-8FAF-E52F-41B4-BBA51D0A7C8C">
<sourceConnName>wtp@XE</sourceConnName>
<sourceObjSchema>WTP</sourceObjSchema>
<sourceObjName>WT_ASSERT</sourceObjName>
<createdBy>Duane</createdBy>
<createdTime>2018-01-21 14:30:36 UTC</createdTime>
<ownerDesignName>wtPLSQL</ownerDesignName>
<owner>8BAEC76D-10C0-D6CD-F400-EACE584ED648</owner>
<source>CREATE OR REPLACE package WTP.WT_ASSERT authid current_user&lt;br/&gt;is&lt;br/&gt;&lt;br/&gt;   -- See RESET_GLOBALS procedure for default global values&lt;br/&gt;&lt;br/&gt;   -- Raise exception whenever an assertion fails.&lt;br/&gt;   --   Modify as required&lt;br/&gt;   g_raise_exception  boolean := FALSE;&lt;br/&gt;&lt;br/&gt;   -- Testcase name for a series of assetions.&lt;br/&gt;   --   Modify as required&lt;br/&gt;   g_testcase         wt_results.testcase%TYPE;&lt;br/&gt;&lt;br/&gt;   function last_pass&lt;br/&gt;   return boolean;&lt;br/&gt;&lt;br/&gt;   function last_assert&lt;br/&gt;   return wt_results.assertion%TYPE;&lt;br/&gt;&lt;br/&gt;   function last_msg&lt;br/&gt;   return wt_results.message%TYPE;&lt;br/&gt;&lt;br/&gt;   function last_details&lt;br/&gt;   return wt_results.details%TYPE;&lt;br/&gt;&lt;br/&gt;   procedure reset_globals;&lt;br/&gt;&lt;br/&gt;   -- Date/Time Formats are configured at the Session Level&lt;br/&gt;   function get_NLS_DATE_FORMAT&lt;br/&gt;      return varchar2;&lt;br/&gt;   procedure set_NLS_DATE_FORMAT&lt;br/&gt;      (in_format in varchar2);&lt;br/&gt;   function get_NLS_TIMESTAMP_FORMAT&lt;br/&gt;      return varchar2;&lt;br/&gt;   procedure set_NLS_TIMESTAMP_FORMAT&lt;br/&gt;      (in_format in varchar2);&lt;br/&gt;   function get_NLS_TIMESTAMP_TZ_FORMAT&lt;br/&gt;       return varchar2;&lt;br/&gt;   procedure set_NLS_TIMESTAMP_TZ_FORMAT&lt;br/&gt;       (in_format in varchar2);&lt;br/&gt;&lt;br/&gt;   ------------------------&lt;br/&gt;   --   Datatypes Supported&lt;br/&gt;   --     Oracle Data Type Families&lt;br/&gt;   --   https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/predefined.htm#LNPLS2047&lt;br/&gt;   --&lt;br/&gt;   -- BFILE*&lt;br/&gt;   -- BLOB*&lt;br/&gt;   -- BOOLEAN&lt;br/&gt;   -- VARCHAR2 - Includes ROWID, LONG, RAW, and NVARCHAR2&lt;br/&gt;   -- CLOB* - Includes NCLOB&lt;br/&gt;   -- DATE - Includes TIMESTAMP and INTERVAL&lt;br/&gt;   -- NUMBER - Includes PLS_INTEGER&lt;br/&gt;   -- XMLTYPE*&lt;br/&gt;   --&lt;br/&gt;   --     Implicit Data Conversion&lt;br/&gt;   --   Note: VARCHAR2, DATE, and NUMBER are combined into VARCHAR2&lt;br/&gt;   --   https://docs.oracle.com/cd/E11882_01/server.112/e41084/sql_elements002.htm#i163326&lt;br/&gt;   --&lt;br/&gt;&lt;br/&gt;   procedure this (&lt;br/&gt;      msg_in          in   varchar2,&lt;br/&gt;      check_this_in   in   boolean,&lt;br/&gt;      null_ok_in      in   boolean := false);&lt;br/&gt;&lt;br/&gt;   procedure eq (&lt;br/&gt;      msg_in            in   varchar2,&lt;br/&gt;      check_this_in     in   varchar2,&lt;br/&gt;      against_this_in   in   varchar2,&lt;br/&gt;      null_ok_in        in   boolean := false);&lt;br/&gt;&lt;br/&gt;   procedure eq (&lt;br/&gt;      msg_in            in   varchar2,&lt;br/&gt;      check_this_in     in   boolean,&lt;br/&gt;      against_this_in   in   boolean,&lt;br/&gt;      null_ok_in        in   boolean := false);&lt;br/&gt;&lt;br/&gt;   procedure isnotnull (&lt;br/&gt;      msg_in          in   varchar2,&lt;br/&gt;      check_this_in   in   varchar2);&lt;br/&gt;&lt;br/&gt;   procedure isnotnull (&lt;br/&gt;      msg_in          in   varchar2,&lt;br/&gt;      check_this_in   in   boolean);&lt;br/&gt;&lt;br/&gt;   procedure isnull (&lt;br/&gt;      msg_in          in   varchar2,&lt;br/&gt;      check_this_in   in   varchar2);&lt;br/&gt;&lt;br/&gt;   procedure isnull (&lt;br/&gt;      msg_in          in   varchar2,&lt;br/&gt;      check_this_in   in   boolean);&lt;br/&gt;&lt;br/&gt;   procedure raises (&lt;br/&gt;      msg_in                varchar2,&lt;br/&gt;      check_call_in    in   varchar2,&lt;br/&gt;      against_exc_in   in   varchar2);&lt;br/&gt;&lt;br/&gt;   procedure eqqueryvalue (&lt;br/&gt;      msg_in             in   varchar2,&lt;br/&gt;      check_query_in     in   varchar2,&lt;br/&gt;      against_value_in   in   varchar2,&lt;br/&gt;      null_ok_in         in   boolean := false);&lt;br/&gt;&lt;br/&gt;   procedure eqquery (&lt;br/&gt;      msg_in             in   varchar2,&lt;br/&gt;      check_query_in     in   varchar2,&lt;br/&gt;      against_query_in   in   varchar2);&lt;br/&gt;&lt;br/&gt;   procedure eqtable (&lt;br/&gt;      msg_in             in   varchar2,&lt;br/&gt;      check_this_in      in   varchar2,&lt;br/&gt;      against_this_in    in   varchar2,&lt;br/&gt;      check_where_in     in   varchar2 := null,&lt;br/&gt;      against_where_in   in   varchar2 := null);&lt;br/&gt;&lt;br/&gt;   procedure eqtabcount (&lt;br/&gt;      msg_in             in   varchar2,&lt;br/&gt;      check_this_in      in   varchar2,&lt;br/&gt;      against_this_in    in   varchar2,&lt;br/&gt;      check_where_in     in   varchar2 := null,&lt;br/&gt;      against_where_in   in   varchar2 := null);&lt;br/&gt;&lt;br/&gt;   procedure objexists (&lt;br/&gt;      msg_in        in   varchar2,&lt;br/&gt;      obj_owner_in  in   varchar2,&lt;br/&gt;      obj_name_in   in   varchar2);&lt;br/&gt;&lt;br/&gt;   procedure objexists (&lt;br/&gt;      msg_in          in   varchar2,&lt;br/&gt;      check_this_in   in   varchar2);&lt;br/&gt;&lt;br/&gt;   procedure objnotexists (&lt;br/&gt;      msg_in        in   varchar2,&lt;br/&gt;      obj_owner_in  in   varchar2,&lt;br/&gt;      obj_name_in   in   varchar2);&lt;br/&gt;&lt;br/&gt;   procedure objnotexists (&lt;br/&gt;      msg_in          in   varchar2,&lt;br/&gt;      check_this_in   in   varchar2);&lt;br/&gt;&lt;br/&gt;end wt_assert;</source>
<body class="oracle.dbtools.crest.model.design.storage.oracle.PackageBodyOracle" name="WT_ASSERT" id="D41A0DE0-8FAF-E52F-41B4-BBA51D0A7C8C">
<sourceConnName>wtp@XE</sourceConnName>
<sourceObjSchema>WTP</sourceObjSchema>
<sourceObjName>WT_ASSERT</sourceObjName>
<createdBy>Duane</createdBy>
<createdTime>2018-01-21 14:30:36 UTC</createdTime>
<ownerDesignName>wtPLSQL</ownerDesignName>
<owner>8BAEC76D-10C0-D6CD-F400-EACE584ED648</owner>
<source>CREATE OR REPLACE package body WTP.WT_ASSERT is&lt;br/&gt;&lt;br/&gt;   -- See (public) RESET_GLOBALS procedure for default global values&lt;br/&gt;   g_last_pass        boolean;&lt;br/&gt;   g_last_assert      wt_results.assertion%TYPE;&lt;br/&gt;   g_last_msg         wt_results.message%TYPE;&lt;br/&gt;   g_last_details     wt_results.details%TYPE;&lt;br/&gt;&lt;br/&gt;----------------------&lt;br/&gt;--  Private Procedures&lt;br/&gt;----------------------&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;function boolean_to_status&lt;br/&gt;      (in_boolean  in boolean)&lt;br/&gt;   return varchar2&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   if in_boolean&lt;br/&gt;   then&lt;br/&gt;      return wt_result.C_PASS;&lt;br/&gt;   end if;&lt;br/&gt;   return wt_result.C_FAIL;&lt;br/&gt;end;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure process_assertion&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   wt_result.save&lt;br/&gt;      (in_assertion      =&gt; g_last_assert&lt;br/&gt;      ,in_status         =&gt; case g_last_pass when TRUE then wt_result.C_PASS&lt;br/&gt;                                                       else wt_result.C_FAIL&lt;br/&gt;                            end&lt;br/&gt;      ,in_details        =&gt; g_last_details&lt;br/&gt;      ,in_testcase       =&gt; g_testcase&lt;br/&gt;      ,in_message        =&gt; g_last_msg);&lt;br/&gt;   if g_raise_exception and not g_last_pass&lt;br/&gt;   then&lt;br/&gt;      raise_application_error(-20000, wt_text_report.format_test_result&lt;br/&gt;                                         (in_assertion      =&gt; g_last_assert&lt;br/&gt;                                         ,in_status         =&gt; case g_last_pass when TRUE then wt_result.C_PASS&lt;br/&gt;                                                                                          else wt_result.C_FAIL&lt;br/&gt;                                                               end&lt;br/&gt;                                         ,in_details        =&gt; g_last_details&lt;br/&gt;                                         ,in_testcase       =&gt; g_testcase&lt;br/&gt;                                         ,in_message        =&gt; g_last_msg) );&lt;br/&gt;   end if;&lt;br/&gt;end process_assertion;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure compare_queries (&lt;br/&gt;      check_query_in     in   varchar2,&lt;br/&gt;      against_query_in   in   varchar2)&lt;br/&gt;is&lt;br/&gt;&lt;br/&gt;   l_ret_txt    varchar2(10);&lt;br/&gt;&lt;br/&gt;   -- Define Query for the Comparison&lt;br/&gt;   l_qry_txt  varchar2(32000) := &apos;with check_query as (&apos; ||&lt;br/&gt;                                 check_query_in ||&lt;br/&gt;                                 &apos;), against_query as (&apos; ||&lt;br/&gt;                                 against_query_in ||&lt;br/&gt;                                 &apos;) select check_query MINUS against_query &apos; ||&lt;br/&gt;                             &apos;UNION select against_query MINUS check_query&apos;;&lt;br/&gt;&lt;br/&gt;   ----------------------------------------&lt;br/&gt;   -- Define EXECUTE IMMEDIATE text&lt;br/&gt;   l_exec_txt   varchar2(32767) :=&lt;br/&gt;&apos;declare&lt;br/&gt;   cursor cur is &apos; || l_qry_txt || &apos;;&lt;br/&gt;   rec cur%rowtype;&lt;br/&gt;begin     &lt;br/&gt;   open cur;&lt;br/&gt;   fetch cur into rec;&lt;br/&gt;	:ret_txt := case cur%FOUND when TRUE then &apos;&apos;FOUND&apos;&apos;&lt;br/&gt;                              else &apos;&apos;NOTFOUND&apos;&apos; end;&lt;br/&gt;   close cur;&lt;br/&gt;end;&apos;;&lt;br/&gt;   ----------------------------------------&lt;br/&gt;&lt;br/&gt;begin&lt;br/&gt;&lt;br/&gt;   -- Run the Comparison&lt;br/&gt;   execute immediate l_exec_txt using out l_ret_txt;&lt;br/&gt;   if l_ret_txt = &apos;FOUND&apos;&lt;br/&gt;   then&lt;br/&gt;      g_last_pass := FALSE; -- Some Difference Found&lt;br/&gt;   else&lt;br/&gt;      g_last_pass := TRUE;  -- Nothing found, queries match&lt;br/&gt;   end if;&lt;br/&gt;   -- No Exceptions Raised&lt;br/&gt;   g_last_details := &apos;Comparison Query: &apos; || l_qry_txt;&lt;br/&gt;&lt;br/&gt;exception&lt;br/&gt;   when OTHERS&lt;br/&gt;   then&lt;br/&gt;      g_last_details := SQLERRM || CHR(10) ||&lt;br/&gt;                        &apos;FAILURE of Compare Query: &apos; || l_qry_txt || &apos;;&apos;;&lt;br/&gt;      g_last_pass    := FALSE;&lt;br/&gt;&lt;br/&gt;end compare_queries;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;---------------------&lt;br/&gt;--  Public Procedures&lt;br/&gt;---------------------&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;function last_pass&lt;br/&gt;   return boolean&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   return g_last_pass;&lt;br/&gt;end last_pass;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;function last_assert&lt;br/&gt;   return wt_results.assertion%TYPE&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   return g_last_assert;&lt;br/&gt;end last_assert;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;function last_msg&lt;br/&gt;   return wt_results.message%TYPE&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   return g_last_msg;&lt;br/&gt;end last_msg;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;function last_details&lt;br/&gt;   return wt_results.details%TYPE&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   return g_last_details;&lt;br/&gt;end last_details;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure reset_globals&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   g_raise_exception := FALSE;&lt;br/&gt;   g_testcase        := &apos;&apos;;&lt;br/&gt;   g_last_pass       := NULL;&lt;br/&gt;   g_last_assert     := &apos;&apos;;&lt;br/&gt;   g_last_msg        := &apos;&apos;;&lt;br/&gt;   g_last_details    := &apos;&apos;;&lt;br/&gt;end reset_globals;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;function get_NLS_DATE_FORMAT&lt;br/&gt;      return varchar2&lt;br/&gt;is&lt;br/&gt;   l_format   varchar2(50);&lt;br/&gt;begin&lt;br/&gt;   select value into l_format&lt;br/&gt;    from  nls_session_parameters&lt;br/&gt;    where parameter in &apos;NLS_DATE_FORMAT&apos;;&lt;br/&gt;   return l_format;&lt;br/&gt;end get_NLS_DATE_FORMAT;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure set_NLS_DATE_FORMAT&lt;br/&gt;      (in_format in varchar2)&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   execute immediate &apos;alter session set NLS_DATE_FORMAT = &apos;&apos;&apos; ||&lt;br/&gt;                      in_format || &apos;&apos;&apos;&apos;;&lt;br/&gt;end set_NLS_DATE_FORMAT;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;function get_NLS_TIMESTAMP_FORMAT&lt;br/&gt;      return varchar2&lt;br/&gt;is&lt;br/&gt;   l_format   varchar2(50);&lt;br/&gt;begin&lt;br/&gt;   select value into l_format&lt;br/&gt;    from  nls_session_parameters&lt;br/&gt;    where parameter in &apos;NLS_TIMESTAMP_FORMAT&apos;;&lt;br/&gt;   return l_format;&lt;br/&gt;end get_NLS_TIMESTAMP_FORMAT;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure set_NLS_TIMESTAMP_FORMAT&lt;br/&gt;      (in_format in varchar2)&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   execute immediate &apos;alter session set NLS_TIMESTAMP_FORMAT = &apos;&apos;&apos; ||&lt;br/&gt;                      in_format || &apos;&apos;&apos;&apos;;&lt;br/&gt;end set_NLS_TIMESTAMP_FORMAT;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;function get_NLS_TIMESTAMP_TZ_FORMAT&lt;br/&gt;      return varchar2&lt;br/&gt;is&lt;br/&gt;   l_format   varchar2(50);&lt;br/&gt;begin&lt;br/&gt;   select value into l_format&lt;br/&gt;    from  nls_session_parameters&lt;br/&gt;    where parameter in &apos;NLS_TIMESTAMP_TZ_FORMAT&apos;;&lt;br/&gt;   return l_format;&lt;br/&gt;end get_NLS_TIMESTAMP_TZ_FORMAT;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure set_NLS_TIMESTAMP_TZ_FORMAT&lt;br/&gt;      (in_format in varchar2)&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   execute immediate &apos;alter session set NLS_TIMESTAMP_TZ_FORMAT = &apos;&apos;&apos; ||&lt;br/&gt;                      in_format || &apos;&apos;&apos;&apos;;&lt;br/&gt;end set_NLS_TIMESTAMP_TZ_FORMAT;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure this (&lt;br/&gt;      msg_in          in   varchar2,&lt;br/&gt;      check_this_in   in   boolean,&lt;br/&gt;      null_ok_in      in   boolean := false)&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   g_last_assert  := &apos;THIS&apos;;&lt;br/&gt;   g_last_msg     := msg_in;&lt;br/&gt;   g_last_pass    := check_this_in;&lt;br/&gt;   g_last_details := &apos;Expected &quot;&apos;  || wt_result.C_PASS ||&lt;br/&gt;                     &apos;&quot; and got &quot;&apos; || boolean_to_status(check_this_in) || &apos;&quot;&apos;;&lt;br/&gt;   process_assertion;&lt;br/&gt;end this;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;-- EQ: string overload&lt;br/&gt;procedure eq (&lt;br/&gt;   msg_in            in   varchar2,&lt;br/&gt;   check_this_in     in   varchar2,&lt;br/&gt;   against_this_in   in   varchar2,&lt;br/&gt;   null_ok_in        in   boolean := false)&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   g_last_assert  := &apos;EQ&apos;;&lt;br/&gt;   g_last_msg     := msg_in;&lt;br/&gt;   g_last_pass    := (   nvl(check_this_in = against_this_in, false)&lt;br/&gt;                      or (    check_this_in is null&lt;br/&gt;                          and against_this_in is null&lt;br/&gt;                          and null_ok_in              )&lt;br/&gt;                     );&lt;br/&gt;   g_last_details := &apos;Expected &quot;&apos;  || against_this_in ||&lt;br/&gt;                     &apos;&quot; and got &quot;&apos; || check_this_in   ||&lt;br/&gt;                     &apos;&quot;&apos;;&lt;br/&gt;   process_assertion;&lt;br/&gt;end eq;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;-- EQ: boolean overload&lt;br/&gt;procedure eq (&lt;br/&gt;   msg_in            in   varchar2,&lt;br/&gt;   check_this_in     in   boolean,&lt;br/&gt;   against_this_in   in   boolean,&lt;br/&gt;   null_ok_in        in   boolean := false)&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   eq (msg_in           =&gt; msg_in&lt;br/&gt;      ,check_this_in    =&gt; boolean_to_status(check_this_in)&lt;br/&gt;      ,against_this_in  =&gt; boolean_to_status(against_this_in)&lt;br/&gt;      ,null_ok_in       =&gt; null_ok_in);&lt;br/&gt;end eq;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;-- ISNOTNULL string overload&lt;br/&gt;procedure isnotnull (&lt;br/&gt;   msg_in          in   varchar2,&lt;br/&gt;   check_this_in   in   varchar2)&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   g_last_assert  := &apos;ISNOTNULL&apos;;&lt;br/&gt;   g_last_msg     := msg_in;&lt;br/&gt;   g_last_pass    := (check_this_in is not null);&lt;br/&gt;   g_last_details := &apos;Expected NOT NULL and got &quot;&apos; ||&lt;br/&gt;                      check_this_in || &apos;&quot;&apos;;&lt;br/&gt;   process_assertion;&lt;br/&gt;end isnotnull;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;-- ISNOTNULL boolean overload&lt;br/&gt;procedure isnotnull (&lt;br/&gt;   msg_in          in   varchar2,&lt;br/&gt;   check_this_in   in   boolean)&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   isnotnull (msg_in        =&gt; msg_in&lt;br/&gt;             ,check_this_in =&gt; boolean_to_status(check_this_in));&lt;br/&gt;end isnotnull;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;-- ISNULL string overload&lt;br/&gt;procedure isnull (&lt;br/&gt;   msg_in          in   varchar2,&lt;br/&gt;   check_this_in   in   varchar2)&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   g_last_assert  := &apos;ISNULL&apos;;&lt;br/&gt;   g_last_msg     := msg_in;&lt;br/&gt;   g_last_pass    := (check_this_in is null);&lt;br/&gt;   g_last_details := &apos;Expected NULL and got &quot;&apos; ||&lt;br/&gt;                      check_this_in || &apos;&quot;&apos;;&lt;br/&gt;   process_assertion;&lt;br/&gt;end isnull;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;-- ISNULL boolean overload&lt;br/&gt;procedure isnull (&lt;br/&gt;   msg_in          in   varchar2,&lt;br/&gt;   check_this_in   in   boolean)&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   isnull (msg_in        =&gt; msg_in&lt;br/&gt;          ,check_this_in =&gt; boolean_to_status(check_this_in));&lt;br/&gt;end isnull;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;--  Check a given call raises an exception&lt;br/&gt;procedure raises (&lt;br/&gt;      msg_in                varchar2,&lt;br/&gt;      check_call_in    in   varchar2,&lt;br/&gt;      against_exc_in   in   varchar2)&lt;br/&gt;is&lt;br/&gt;   l_sqlerrm    varchar2(4000);&lt;br/&gt;   l_errstack   varchar2(4000);&lt;br/&gt;begin&lt;br/&gt;   --&lt;br/&gt;   g_last_assert  := &apos;RAISES&apos;;&lt;br/&gt;   g_last_msg     := msg_in;&lt;br/&gt;   --&lt;br/&gt;   begin&lt;br/&gt;      execute immediate &apos;begin &apos; || check_call_in || &apos;; end;&apos;;&lt;br/&gt;   exception when OTHERS then&lt;br/&gt;      l_sqlerrm := SQLERRM;&lt;br/&gt;      l_errstack := substr(dbms_utility.format_error_stack  ||&lt;br/&gt;                           dbms_utility.format_error_backtrace&lt;br/&gt;                           ,1,4000);&lt;br/&gt;   end;&lt;br/&gt;   if l_sqlerrm like &apos;%&apos; || against_exc_in || &apos;%&apos;&lt;br/&gt;   then&lt;br/&gt;      g_last_pass := TRUE;&lt;br/&gt;   else&lt;br/&gt;      g_last_pass := FALSE;&lt;br/&gt;   end if;&lt;br/&gt;   --&lt;br/&gt;   g_last_details := &apos;Expected exception &quot;&apos; || against_exc_in ||&lt;br/&gt;                     &apos;&quot;.  Actual exception raised was &quot;&apos; || l_errstack ||&lt;br/&gt;                           &apos;&quot;. Exeption raised by: &apos; || check_call_in  ;&lt;br/&gt;   process_assertion;&lt;br/&gt;end raises;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure eqqueryvalue (&lt;br/&gt;      msg_in             in   varchar2,&lt;br/&gt;      check_query_in     in   varchar2,&lt;br/&gt;      against_value_in   in   varchar2,&lt;br/&gt;      null_ok_in         in   boolean := false)&lt;br/&gt;is&lt;br/&gt;   type rc_type is ref cursor;&lt;br/&gt;   l_rc          rc_type;&lt;br/&gt;   l_rc_buff     varchar2 (32000);&lt;br/&gt;begin&lt;br/&gt;   --&lt;br/&gt;   g_last_assert  := &apos;EQQUERYVALUE&apos;;&lt;br/&gt;   g_last_msg     := msg_in;&lt;br/&gt;   --&lt;br/&gt;   open l_rc for check_query_in;&lt;br/&gt;   fetch l_rc into l_rc_buff;&lt;br/&gt;   close l_rc;&lt;br/&gt;   --&lt;br/&gt;   g_last_pass    := (   l_rc_buff = against_value_in&lt;br/&gt;                      or (    l_rc_buff is null&lt;br/&gt;                          and against_value_in is null&lt;br/&gt;                          and null_ok_in               )  );&lt;br/&gt;   g_last_details := &apos;Expected &quot;&apos; || against_value_in ||&lt;br/&gt;                    &apos;&quot; and got &quot;&apos; || l_rc_buff        ||&lt;br/&gt;                  &apos;&quot; for Query: &apos; || check_query_in   ;&lt;br/&gt;   --&lt;br/&gt;   process_assertion;&lt;br/&gt;   --&lt;br/&gt;end eqqueryvalue;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure eqquery (&lt;br/&gt;      msg_in             in   varchar2,&lt;br/&gt;      check_query_in     in   varchar2,&lt;br/&gt;      against_query_in   in   varchar2)&lt;br/&gt;is&lt;br/&gt;begin&lt;br/&gt;   g_last_assert  := &apos;EQQUERY&apos;;&lt;br/&gt;   g_last_msg     := msg_in;&lt;br/&gt;   compare_queries(check_query_in, against_query_in);&lt;br/&gt;   process_assertion;&lt;br/&gt;end eqquery;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure eqtable (&lt;br/&gt;      msg_in             in   varchar2,&lt;br/&gt;      check_this_in      in   varchar2,&lt;br/&gt;      against_this_in    in   varchar2,&lt;br/&gt;      check_where_in     in   varchar2 := null,&lt;br/&gt;      against_where_in   in   varchar2 := null)&lt;br/&gt;is&lt;br/&gt;   l_check_query    varchar2(16000) := &apos;select * from &apos; || check_this_in;&lt;br/&gt;   l_against_query  varchar2(16000) := &apos;select * from &apos; || against_this_in;&lt;br/&gt;begin&lt;br/&gt;   g_last_assert  := &apos;EQTABLE&apos;;&lt;br/&gt;   g_last_msg     := msg_in;&lt;br/&gt;   if check_where_in is not null&lt;br/&gt;   then&lt;br/&gt;      l_check_query := l_check_query || &apos; where &apos; || check_where_in;&lt;br/&gt;   end if;&lt;br/&gt;   if against_where_in is not null&lt;br/&gt;   then&lt;br/&gt;      l_against_query := l_against_query || &apos; where &apos; || against_where_in;&lt;br/&gt;   end if;&lt;br/&gt;   compare_queries(l_check_query, l_against_query);&lt;br/&gt;   process_assertion;&lt;br/&gt;end eqtable;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure eqtabcount (&lt;br/&gt;      msg_in             in   varchar2,&lt;br/&gt;      check_this_in      in   varchar2,&lt;br/&gt;      against_this_in    in   varchar2,&lt;br/&gt;      check_where_in     in   varchar2 := null,&lt;br/&gt;      against_where_in   in   varchar2 := null)&lt;br/&gt;is&lt;br/&gt;   l_query      varchar2(16000) := &apos;select count(*) from &apos; || check_this_in;&lt;br/&gt;   l_cnt        number;&lt;br/&gt;   l_success    boolean;&lt;br/&gt;   l_check_cnt  number;&lt;br/&gt;   procedure run_query is&lt;br/&gt;      type rc_type is ref cursor;&lt;br/&gt;      l_rc rc_type;&lt;br/&gt;   begin&lt;br/&gt;      open l_rc for l_query;&lt;br/&gt;      fetch l_rc into l_cnt;&lt;br/&gt;      close l_rc;&lt;br/&gt;      l_success := TRUE;&lt;br/&gt;   exception&lt;br/&gt;      when OTHERS&lt;br/&gt;      then&lt;br/&gt;         g_last_details := SQLERRM || CHR(10) ||&lt;br/&gt;                           &apos;FAILURE of Compare Query: &apos; || l_query || &apos;;&apos;;&lt;br/&gt;         g_last_pass    := FALSE;&lt;br/&gt;         process_assertion;&lt;br/&gt;         l_success      := FALSE;&lt;br/&gt;   end run_query;&lt;br/&gt;begin&lt;br/&gt;   --&lt;br/&gt;   g_last_assert  := &apos;EQTABLE&apos;;&lt;br/&gt;   g_last_msg     := msg_in;&lt;br/&gt;   --&lt;br/&gt;   l_query := &apos;select count(*) from &apos; || check_this_in;&lt;br/&gt;   if check_where_in is not null&lt;br/&gt;   then&lt;br/&gt;      l_query := l_query || &apos; where &apos; || check_where_in;&lt;br/&gt;   end if;&lt;br/&gt;   run_query;&lt;br/&gt;   if NOT l_success then return; end if;&lt;br/&gt;   l_check_cnt := l_cnt;&lt;br/&gt;   --&lt;br/&gt;   l_query := &apos;select count(*) from &apos; || against_this_in;&lt;br/&gt;   if against_where_in is not null&lt;br/&gt;   then&lt;br/&gt;      l_query := l_query || &apos; where &apos; || against_where_in;&lt;br/&gt;   end if;&lt;br/&gt;   run_query;&lt;br/&gt;   if NOT l_success then return; end if;&lt;br/&gt;   g_last_pass    := (l_check_cnt = l_cnt);&lt;br/&gt;   --&lt;br/&gt;   g_last_details := &apos;Expected &apos;  || l_cnt       || &apos; rows from &quot;&apos; || against_this_in ||&lt;br/&gt;                     &apos;&quot; and got &apos; || l_check_cnt || &apos; rows from &quot;&apos; || check_this_in   ||&lt;br/&gt;                     &apos;&quot;&apos;;&lt;br/&gt;   process_assertion;&lt;br/&gt;end eqtabcount;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure objexists (&lt;br/&gt;      msg_in        in   varchar2,&lt;br/&gt;      obj_owner_in  in   varchar2,&lt;br/&gt;      obj_name_in   in   varchar2)&lt;br/&gt;is&lt;br/&gt;   l_num_objects  number;&lt;br/&gt;begin&lt;br/&gt;   g_last_assert  := &apos;OBJEXISTS&apos;;&lt;br/&gt;   g_last_msg     := msg_in;&lt;br/&gt;   select count(*) into l_num_objects&lt;br/&gt;    from  all_objects&lt;br/&gt;    where object_name = obj_name_in&lt;br/&gt;     and  (   obj_owner_in is null&lt;br/&gt;           or obj_owner_in = owner);&lt;br/&gt;   g_last_pass    := case l_num_objects when 0 then FALSE else TRUE end;&lt;br/&gt;   g_last_details := &apos;Number of objects found for &quot;&apos; ||&lt;br/&gt;                      case when obj_owner_in is null then &apos;&apos;&lt;br/&gt;                           else obj_owner_in || &apos;.&apos; end ||&lt;br/&gt;                      obj_name_in || &apos;&quot; is &apos; || l_num_objects;&lt;br/&gt;   process_assertion;&lt;br/&gt;end objexists;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure objexists (&lt;br/&gt;      msg_in          in   varchar2,&lt;br/&gt;      check_this_in   in   varchar2)&lt;br/&gt;is&lt;br/&gt;   l_pos    number := instr(check_this_in, &apos;.&apos;);&lt;br/&gt;begin&lt;br/&gt;   objexists(msg_in       =&gt; msg_in&lt;br/&gt;            ,obj_owner_in =&gt; substr(check_this_in, 1, l_pos-1)&lt;br/&gt;            ,obj_name_in  =&gt; substr(check_this_in, l_pos+1, length(check_this_in)));&lt;br/&gt;end objexists;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure objnotexists (&lt;br/&gt;      msg_in        in   varchar2,&lt;br/&gt;      obj_owner_in  in   varchar2,&lt;br/&gt;      obj_name_in   in   varchar2)&lt;br/&gt;is&lt;br/&gt;   l_num_objects  number;&lt;br/&gt;begin&lt;br/&gt;   g_last_assert  := &apos;OBJNOTEXISTS&apos;;&lt;br/&gt;   g_last_msg     := msg_in;&lt;br/&gt;   select count(*) into l_num_objects&lt;br/&gt;    from  all_objects&lt;br/&gt;    where object_name = obj_name_in&lt;br/&gt;     and  (   obj_owner_in is null&lt;br/&gt;           or obj_owner_in = owner);&lt;br/&gt;   g_last_pass    := case l_num_objects when 0 then TRUE else FALSE end;&lt;br/&gt;   g_last_details := &apos;Number of objects found for &quot;&apos; ||&lt;br/&gt;                      case when obj_owner_in is null then &apos;&apos;&lt;br/&gt;                           else obj_owner_in || &apos;.&apos; end ||&lt;br/&gt;                      obj_name_in || &apos;&quot; is &apos; || l_num_objects;&lt;br/&gt;   process_assertion;&lt;br/&gt;end objnotexists;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;procedure objnotexists (&lt;br/&gt;      msg_in          in   varchar2,&lt;br/&gt;      check_this_in   in   varchar2)&lt;br/&gt;is&lt;br/&gt;   l_pos    number := instr(check_this_in, &apos;.&apos;);&lt;br/&gt;begin&lt;br/&gt;   objnotexists(msg_in       =&gt; msg_in&lt;br/&gt;               ,obj_owner_in =&gt; substr(check_this_in, 1, l_pos-1)&lt;br/&gt;               ,obj_name_in  =&gt; substr(check_this_in, l_pos+1, length(check_this_in)));&lt;br/&gt;end objnotexists;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;------------------------------------------------------------&lt;br/&gt;begin&lt;br/&gt;&lt;br/&gt;   reset_globals;&lt;br/&gt;&lt;br/&gt;end wt_assert;</source>
</body>
<synonyms>
<Synonym class="oracle.dbtools.crest.model.design.storage.oracle.v10g.SynonymOraclev10g" name="WT_ASSERT" directorySegmentName="seg_0" id="92E9586E-0B2F-08EF-8A26-E4B3E5EF6402">
<sourceConnName>wtp@XE</sourceConnName>
<sourceObjSchema>PUBLIC</sourceObjSchema>
<sourceObjName>WT_ASSERT</sourceObjName>
<createdBy>Duane</createdBy>
<createdTime>2018-01-21 14:30:36 UTC</createdTime>
<ownerDesignName>wtPLSQL</ownerDesignName>
<object>WT_ASSERT</object>
<objectUser>8BAEC76D-10C0-D6CD-F400-EACE584ED648</objectUser>
<public>YES</public>
<user>PUBLIC</user>
<referredObjectID>D41A0DE0-8FAF-E52F-41B4-BBA51D0A7C8C</referredObjectID>
</Synonym>
</synonyms>
</PackageOracle>